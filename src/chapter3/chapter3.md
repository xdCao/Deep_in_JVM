#第二部分 自动内存管理机制

##第三章 垃圾收集器与内存分配策略

-XX:+PrintGCDetails

###一、概述

垃圾收集器关注的内存：方法区、java堆（因为这部分内存的分配和回收都是动态的）

###二、对象已死吗（判断对象是否存活）

####计数算法：
给对象中添加一个引用计数器，每当有一个地方引用它时，加一，引用失效时，减一

主流的java虚拟机不采用这种方法，原因：

难以解决对象之间的循环引用问题

####可达性分析算法

通过一系列成为“GC ROOTS”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，

当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象是不可用的

可作为GC ROOTS的对象：

    虚拟机栈（栈帧中的本地变量表）中引用的对象
    
    方法区中类静态属性引用的对象
    
    方法区中常量引用的对象
    
    本地方法栈中JNI引用的对象
    
####关于引用

强-----------------------------------------------》弱

  强引用---》软引用---》弱引用---》虚引用

强引用：只要强引用存在，GC永远不会回收掉被引用的对象

软引用：（SoftReference）描述还有用但并非必须的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围中
进行第二次回收，如果还是没有足够的内存，才报OOM

弱引用：（WeakReference）描述非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前

虚引用：（PhantomReference）一个对象是否有虚引用完全不会影响其生存时间，也无法通过虚引用来取得对象实例。

为一个对象设置虚引用关联的唯一目的：能在这个对象被收集器回收时收到一个系统通知

####生死存亡（两次标记）

如果对象在进行可达性分析后发现没有雨GC ROOTS的引用链：

进行第一次标记并筛选，删选条件：此对象是否有必要执行finalize方法。
若对象没有覆盖finalize方法或该方法已经被虚拟机调用过，则认为没有必要执行

若认为有必要执行，对象被放置到F-Queue中，由Finalizer线程去触发其finalize方法，此时是对象拯救自身的最后机会，可以通过finalize方法将自己移出回收
 队列，稍后GC进行第二次标记。两次标记结束后，还在回收队列的被回收。
 
    可怜的finalize方法，不要去用它。
    
####回收方法区

无用类：

    java堆中不存在该类的任何实例
    加载该类的ClassLoader已经被回收
    该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
    
-verbose:class

-XX:+TraceClassLoading  -XX:+TraceClassUnLoading

在大量使用反射、动态代理、CGLib、JSP、OSGI等频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证
方法区不会溢出

###三、GC算法

####1、标记-清除算法

标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。

不足：
    
    1、效率：标记和清除两个过程的效率都不高
    2、空间：标记清除后会产生大量不连续的内存碎片
    
####2、复制算法

解决效率问题

